{
  "Uuid": "600ffd45-ff9b-4358-bf6b-8dfab6283da6",
  "IsCustomNode": false,
  "Description": "",
  "Name": "Check json Topology",
  "ElementResolver": {
    "ResolutionMap": {}
  },
  "Inputs": [],
  "Outputs": [],
  "Nodes": [
    {
      "ConcreteType": "CoreNodeModels.Input.Filename, CoreNodeModels",
      "Id": "dcd67bb8cb174bfd8eb46b274ec43096",
      "NodeType": "ExtensionNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "af44f2bcacaa4d169e8520dedc4fb9f5",
          "Name": "",
          "Description": "File Path",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Allows you to select a file on the system and returns its file path",
      "HintPath": "C:\\Users\\JacksonAugusto\\Documents\\GitHub\\WWTpyRevit\\WWT Tools.extension\\WWT Tools.tab\\Work Set.panel\\Cable Length Calculation.pushbutton\\topologic.JSON",
      "InputValue": "C:\\Users\\JacksonAugusto\\Documents\\GitHub\\WWTpyRevit\\WWT Tools.extension\\WWT Tools.tab\\Work Set.panel\\Cable Length Calculation.pushbutton\\topologic.JSON"
    },
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "Code": "# Dynamo Python: Visualize topologic.JSON (graph export from pyRevit script)\r\n# Compatible with IronPython2 and CPython3.\r\n#\r\n# IN[0] : path (string) to topologic.JSON\r\n#\r\n# OUT:\r\n#   0 -> Status / Messages\r\n#   1 -> DS Points (vertices) list\r\n#   2 -> DS Lines (edges) list (Line.ByStartPointEndPoint)\r\n#   3 -> End Point (DS Point or None)\r\n#   4 -> Start Points (list of DS Points in same order as start_points array)\r\n#   5 -> Start Point Element IDs (parallel list of element_id)\r\n#   6 -> Meta dictionary (if present)\r\n#   7 -> Vertex Count\r\n#   8 -> Edge Count\r\n#   9 -> Mapping (vertex index -> Point) (list)\r\n#\r\n# Notes:\r\n# - Assumes coordinates are in Revit internal units (feet). No unit conversion performed.\r\n# - Handles absence of meta gracefully.\r\n# - If JSON contains duplicate vertices (rare), returns them as-is.\r\n#\r\nimport json, os, sys, traceback\r\n\r\n# Dynamo geometry imports (works in both engines)\r\ntry:\r\n    import clr\r\n    clr.AddReference('ProtoGeometry')\r\n    from Autodesk.DesignScript.Geometry import Point as DSPoint\r\n    from Autodesk.DesignScript.Geometry import Line\r\nexcept Exception as e:\r\n    OUT = [\"ERROR: Could not import Dynamo geometry: {}\".format(e)], [], [], None, [], [], {}, 0, 0, []\r\n    raise\r\n\r\npath = IN[0] if len(IN) > 0 else None\r\nmessages = []\r\n\r\ndef fail(msg):\r\n    return [msg], [], [], None, [], [], {}, 0, 0, []\r\n\r\nif not path or not isinstance(path, str) or path.strip()==\"\":\r\n    OUT = fail(\"No file path provided for topologic.JSON.\")\r\nelse:\r\n    path = path.strip('\"').strip()\r\n    if not os.path.exists(path):\r\n        OUT = fail(\"File not found: {}\".format(path))\r\n    else:\r\n        try:\r\n            with open(path, 'r') as f:\r\n                data = json.load(f)\r\n            vertices = data.get(\"vertices\", [])\r\n            edges = data.get(\"edges\", [])\r\n            start_points_raw = data.get(\"start_points\", [])\r\n            end_pt_raw = data.get(\"end_point\", None)\r\n            meta = data.get(\"meta\", {})\r\n\r\n            # Build DS Points\r\n            ds_vertices = []\r\n            for v in vertices:\r\n                try:\r\n                    ds_vertices.append(DSPoint.ByCoordinates(float(v[0]), float(v[1]), float(v[2])))\r\n                except:\r\n                    ds_vertices.append(None)\r\n                    messages.append(\"Vertex conversion failed for: {}\".format(v))\r\n\r\n            # Build DS Lines (edges reference indices)\r\n            ds_edges = []\r\n            for e in edges:\r\n                try:\r\n                    a, b = int(e[0]), int(e[1])\r\n                    if 0 <= a < len(ds_vertices) and 0 <= b < len(ds_vertices):\r\n                        pa = ds_vertices[a]; pb = ds_vertices[b]\r\n                        if pa and pb:\r\n                            ds_edges.append(Line.ByStartPointEndPoint(pa, pb))\r\n                        else:\r\n                            messages.append(\"Null vertex in edge {} -> skipped\".format(e))\r\n                    else:\r\n                        messages.append(\"Edge index out of range: {}\".format(e))\r\n                except Exception as ex:\r\n                    messages.append(\"Edge parse error {} : {}\".format(e, ex))\r\n\r\n            # Start points\r\n            sp_points = []\r\n            sp_ids = []\r\n            for sp in start_points_raw:\r\n                try:\r\n                    p = sp.get(\"point\")\r\n                    eid = sp.get(\"element_id\")\r\n                    if p and len(p) == 3:\r\n                        sp_points.append(DSPoint.ByCoordinates(float(p[0]), float(p[1]), float(p[2])))\r\n                    else:\r\n                        sp_points.append(None)\r\n                        messages.append(\"Invalid start point coords: {}\".format(p))\r\n                    sp_ids.append(eid)\r\n                except Exception as ex:\r\n                    messages.append(\"Start point conversion error: {}\".format(ex))\r\n                    sp_points.append(None)\r\n                    sp_ids.append(None)\r\n\r\n            # End point\r\n            end_pt = None\r\n            if end_pt_raw and len(end_pt_raw) == 3:\r\n                try:\r\n                    end_pt = DSPoint.ByCoordinates(float(end_pt_raw[0]), float(end_pt_raw[1]), float(end_pt_raw[2]))\r\n                except Exception as ex:\r\n                    messages.append(\"End point conversion error: {}\".format(ex))\r\n\r\n            messages.insert(0, \"Loaded topologic.JSON successfully.\")\r\n            messages.append(\"Vertices: {} | Edges: {} | StartPoints: {}\"\r\n                            .format(len(vertices), len(edges), len(sp_points)))\r\n\r\n            OUT = [\r\n                messages,          # 0\r\n                ds_vertices,       # 1\r\n                ds_edges,          # 2\r\n                end_pt,            # 3\r\n                sp_points,         # 4\r\n                sp_ids,            # 5\r\n                meta,              # 6\r\n                len(vertices),     # 7\r\n                len(edges),        # 8\r\n                ds_vertices        # 9 (simple mapping list)\r\n            ]\r\n        except Exception as e:\r\n            tb = traceback.format_exc()\r\n            OUT = fail(\"Failed parsing JSON: {}\\n{}\".format(e, tb))",
      "Engine": "CPython3",
      "VariableInputPorts": true,
      "Id": "383cf8973b224494bc49069d2203d5fd",
      "NodeType": "PythonScriptNode",
      "Inputs": [
        {
          "Id": "213144805f584190a540d3c9270fc1df",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "e7cda9adab064747a2d3235ec85e80ef",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded Python script."
    },
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "Code": "# Dynamo Python: Robust visualization of topologic_results.json\r\n# Compatible with IronPython2 and CPython3 engines.\r\n#\r\n# IN[0] : File path to topologic_results.json\r\n#\r\n# OUT indexes:\r\n# 0 messages (list of strings)\r\n# 1 meta dict (or {})\r\n# 2 element_ids_str (list of element_id as STRING)\r\n# 3 element_ids_int (list of element_id as INT or None where not numeric)\r\n# 4 lengths (list, float or None)\r\n# 5 path_points (list of lists of DS Points)\r\n# 6 path_polycurves (list of PolyCurve or None)\r\n# 7 id_to_length_dict (keys are STRING)\r\n# 8 success_count\r\n# 9 failure_count\r\n# 10 merged_polycurve (single PolyCurve of all path segments or None)\r\n#\r\nimport json, os, sys, traceback\r\n\r\n# Geometry imports\r\ntry:\r\n    import clr\r\n    clr.AddReference('ProtoGeometry')\r\n    from Autodesk.DesignScript.Geometry import Point as DSPoint\r\n    from Autodesk.DesignScript.Geometry import Line, PolyCurve\r\nexcept Exception as e:\r\n    OUT = [[\"ERROR importing Dynamo geometry: {}\".format(e)], {}, [], [], [], [], [], {}, 0, 0, None]\r\n    raise\r\n\r\npath = IN[0] if len(IN)>0 else None\r\nmessages=[]\r\n\r\ndef fail(msg):\r\n    return [msg], {}, [], [], [], [], [], {}, 0, 0, None\r\n\r\ndef to_float(x):\r\n    try:\r\n        # Handle numpy types or anything convertible\r\n        return float(x)\r\n    except:\r\n        return None\r\n\r\ndef coerce_point_list(raw):\r\n    \"\"\"Return list of (x,y,z) floats or []\"\"\"\r\n    pts=[]\r\n    if not raw: return pts\r\n    for r in raw:\r\n        try:\r\n            if isinstance(r,(list,tuple)) and len(r)>=3:\r\n                x=to_float(r[0]); y=to_float(r[1]); z=to_float(r[2])\r\n                if None not in (x,y,z):\r\n                    pts.append((x,y,z))\r\n        except:\r\n            pass\r\n    return pts\r\n\r\ndef make_ds_points(pt_tuples):\r\n    ds=[]\r\n    for p in pt_tuples:\r\n        try:\r\n            ds.append(DSPoint.ByCoordinates(p[0],p[1],p[2]))\r\n        except:\r\n            ds.append(None)\r\n    return ds\r\n\r\ndef build_polycurve(ds_pts):\r\n    # Filter None & duplicates\r\n    clean=[]\r\n    last=None\r\n    for p in ds_pts:\r\n        if p and (last is None or p.DistanceTo(last)>1e-10):\r\n            clean.append(p); last=p\r\n    if len(clean)<2:\r\n        return None\r\n    try:\r\n        lines=[]\r\n        for i in range(len(clean)-1):\r\n            a=clean[i]; b=clean[i+1]\r\n            if a.DistanceTo(b)>1e-10:\r\n                lines.append(Line.ByStartPointEndPoint(a,b))\r\n        if not lines:\r\n            return None\r\n        return PolyCurve.ByJoinedCurves(lines)\r\n    except:\r\n        return None\r\n\r\nif not path or not isinstance(path,str) or path.strip()==\"\":\r\n    OUT = fail(\"No file path provided.\")\r\nelse:\r\n    path=path.strip('\"').strip()\r\n    if not os.path.exists(path):\r\n        OUT = fail(\"File not found: {}\".format(path))\r\n    else:\r\n        try:\r\n            with open(path,'r') as f:\r\n                raw = json.load(f)\r\n        except Exception as e:\r\n            OUT = fail(\"JSON load error: {}\".format(e))\r\n        else:\r\n            meta={}\r\n            results=[]\r\n            # Schema detection\r\n            if isinstance(raw, dict) and \"results\" in raw:\r\n                meta = raw.get(\"meta\", {})\r\n                results = raw.get(\"results\", [])\r\n            elif isinstance(raw, list):\r\n                results = raw\r\n                meta = {}\r\n            elif isinstance(raw, dict):\r\n                # Possibly dict keyed by element_id; separate meta if present\r\n                meta = raw.get(\"meta\", {})\r\n                # Build list from numeric/string keys excluding 'meta'\r\n                for k,v in raw.items():\r\n                    if k==\"meta\": continue\r\n                    if isinstance(v, dict):\r\n                        rec = v.copy()\r\n                        rec.setdefault(\"element_id\", k)\r\n                        results.append(rec)\r\n            else:\r\n                OUT = fail(\"Unrecognized JSON structure.\")\r\n                sys.exit()\r\n\r\n            element_ids_str=[]\r\n            element_ids_int=[]\r\n            lengths=[]\r\n            path_points_ds=[]\r\n            path_poly=[]\r\n            id_to_length={}\r\n            success=0\r\n            failure=0\r\n\r\n            for idx,res in enumerate(results):\r\n                if not isinstance(res, dict):\r\n                    messages.append(\"Skipping non-dict result at index {}\".format(idx))\r\n                    failure+=1\r\n                    element_ids_str.append(None); element_ids_int.append(None)\r\n                    lengths.append(None); path_points_ds.append([]); path_poly.append(None)\r\n                    continue\r\n                eid_raw = res.get(\"element_id\", res.get(\"id\", None))\r\n                # Convert element id to string\r\n                eid_str = str(eid_raw) if eid_raw is not None else \"None\"\r\n                try:\r\n                    eid_int = int(eid_raw)\r\n                except:\r\n                    eid_int = None\r\n                length = res.get(\"length\", res.get(\"path_length\", None))\r\n                if length is not None:\r\n                    length = to_float(length)\r\n                # Find path coordinates (try multiple keys)\r\n                coord_keys = [\"vertex_path_xyz\",\"path_xyz\",\"path\",\"points\",\"coords\"]\r\n                coord_data = None\r\n                for k in coord_keys:\r\n                    if k in res:\r\n                        coord_data = res[k]\r\n                        break\r\n                pts = coerce_point_list(coord_data)\r\n                ds_pts = make_ds_points(pts)\r\n                poly = build_polycurve(ds_pts)\r\n\r\n                element_ids_str.append(eid_str)\r\n                element_ids_int.append(eid_int)\r\n                lengths.append(length)\r\n                path_points_ds.append(ds_pts)\r\n                path_poly.append(poly)\r\n                id_to_length[eid_str]=length\r\n\r\n                if length is not None and poly:\r\n                    success+=1\r\n                else:\r\n                    failure+=1\r\n                    if length is None:\r\n                        messages.append(\"No length for element_id {}\".format(eid_str))\r\n                    if not poly:\r\n                        messages.append(\"No polycurve for element_id {} (pts={})\".format(eid_str, len(ds_pts)))\r\n\r\n            # Attempt merged polycurve (all segments)\r\n            merged_poly=None\r\n            try:\r\n                all_lines=[]\r\n                for pc in path_poly:\r\n                    if pc:\r\n                        # Decompose polycurve into lines\r\n                        try:\r\n                            sub_curves=pc.Curves()\r\n                            for sc in sub_curves:\r\n                                all_lines.append(sc)\r\n                        except:\r\n                            all_lines.append(pc)\r\n                if all_lines:\r\n                    merged_poly = PolyCurve.ByJoinedCurves(all_lines)\r\n            except Exception as e:\r\n                messages.append(\"Merged polycurve creation failed: {}\".format(e))\r\n                merged_poly=None\r\n\r\n            messages.insert(0, \"Loaded {} result records. Success: {} Failure: {}\".format(len(results), success, failure))\r\n            OUT = [\r\n                messages,           # 0\r\n                meta,               # 1\r\n                element_ids_str,    # 2\r\n                element_ids_int,    # 3\r\n                lengths,            # 4\r\n                path_points_ds,     # 5\r\n                path_poly,          # 6\r\n                id_to_length,       # 7 (string keys to avoid Int64 cast issues)\r\n                success,            # 8\r\n                failure,            # 9\r\n                merged_poly         # 10\r\n            ]",
      "Engine": "CPython3",
      "VariableInputPorts": true,
      "Id": "0ca28f3674604398a3938bc7bbdc69b3",
      "NodeType": "PythonScriptNode",
      "Inputs": [
        {
          "Id": "3153e6623b7e4ef1b0be458afe4c04b0",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "361d7b4b9d97479482009879606ed5cd",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded Python script."
    },
    {
      "ConcreteType": "CoreNodeModels.Input.Filename, CoreNodeModels",
      "Id": "eaa281ca188b44dca87a407fb889d3a6",
      "NodeType": "ExtensionNode",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "db602e6595394efd9a985c5eb14c973e",
          "Name": "",
          "Description": "File Path",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Allows you to select a file on the system and returns its file path",
      "HintPath": "C:\\Users\\JacksonAugusto\\Documents\\GitHub\\WWTpyRevit\\WWT Tools.extension\\WWT Tools.tab\\Work Set.panel\\Cable Length Calculation.pushbutton\\topologic_results.json",
      "InputValue": "C:\\Users\\JacksonAugusto\\Documents\\GitHub\\WWTpyRevit\\WWT Tools.extension\\WWT Tools.tab\\Work Set.panel\\Cable Length Calculation.pushbutton\\topologic_results.json"
    },
    {
      "ConcreteType": "DataShapesZT.DataShapesZT.GeomPreviewNodeModel, DataShapesZT",
      "SliderValue": 255.0,
      "rValue": "255",
      "gValue": "26",
      "bValue": "76",
      "Id": "615b0f583f174f1882622e2d62574d16",
      "NodeType": "ExtensionNode",
      "Inputs": [
        {
          "Id": "5a733321358b4c00887b097403a98ccc",
          "Name": "Geometry",
          "Description": "Input Geometry",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "79752b6d22d84f029aefe9a2966684dd",
          "Name": "GeometryColor",
          "Description": "Display Geometry",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "UI Node to customize geometry previews."
    },
    {
      "ConcreteType": "DataShapesZT.DataShapesZT.GeomPreviewNodeModel, DataShapesZT",
      "SliderValue": 255.0,
      "rValue": "36",
      "gValue": "53",
      "bValue": "255",
      "Id": "d63d1b17a5be409e8da20c72b3e4bd05",
      "NodeType": "ExtensionNode",
      "Inputs": [
        {
          "Id": "68d6a1a25b65428fb49671e5fdaafd4a",
          "Name": "Geometry",
          "Description": "Input Geometry",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "f020b632f29d4d3a821f1c874916987e",
          "Name": "GeometryColor",
          "Description": "Display Geometry",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "UI Node to customize geometry previews."
    }
  ],
  "Connectors": [
    {
      "Start": "af44f2bcacaa4d169e8520dedc4fb9f5",
      "End": "213144805f584190a540d3c9270fc1df",
      "Id": "72f5babd188f433ea760abf94b62f15b",
      "IsHidden": "False"
    },
    {
      "Start": "e7cda9adab064747a2d3235ec85e80ef",
      "End": "68d6a1a25b65428fb49671e5fdaafd4a",
      "Id": "7bc627fc23304354934f557b014d1eb4",
      "IsHidden": "False"
    },
    {
      "Start": "361d7b4b9d97479482009879606ed5cd",
      "End": "5a733321358b4c00887b097403a98ccc",
      "Id": "8c44cd130b29465e81c5b012d9801271",
      "IsHidden": "False"
    },
    {
      "Start": "db602e6595394efd9a985c5eb14c973e",
      "End": "3153e6623b7e4ef1b0be458afe4c04b0",
      "Id": "09c61785f54f4c1cac1dadbe4d67fee4",
      "IsHidden": "False"
    }
  ],
  "Dependencies": [],
  "NodeLibraryDependencies": [
    {
      "Name": "Data-Shapes",
      "Version": "2025.3.120",
      "ReferenceType": "Package",
      "Nodes": [
        "615b0f583f174f1882622e2d62574d16",
        "d63d1b17a5be409e8da20c72b3e4bd05"
      ]
    },
    {
      "Name": "topologic.JSON",
      "ReferenceType": "External",
      "Nodes": [
        "dcd67bb8cb174bfd8eb46b274ec43096"
      ]
    },
    {
      "Name": "topologic_results.json",
      "ReferenceType": "External",
      "Nodes": [
        "eaa281ca188b44dca87a407fb889d3a6"
      ]
    }
  ],
  "EnableLegacyPolyCurveBehavior": null,
  "Thumbnail": "",
  "GraphDocumentationURL": null,
  "ExtensionWorkspaceData": [
    {
      "ExtensionGuid": "28992e1d-abb9-417f-8b1b-05e053bee670",
      "Name": "Properties",
      "Version": "3.5",
      "Data": {}
    },
    {
      "ExtensionGuid": "DFBD9CC0-DB40-457A-939E-8C8555555A9D",
      "Name": "Generative Design",
      "Version": "9.1",
      "Data": {}
    }
  ],
  "Author": "",
  "Linting": {
    "activeLinter": "None",
    "activeLinterId": "7b75fb44-43fd-4631-a878-29f4d5d8399a",
    "warningCount": 0,
    "errorCount": 0
  },
  "Bindings": [],
  "View": {
    "Dynamo": {
      "ScaleFactor": 1.0,
      "HasRunWithoutCrash": true,
      "IsVisibleInDynamoLibrary": true,
      "Version": "3.5.2.8914",
      "RunType": "Manual",
      "RunPeriod": "1000"
    },
    "Camera": {
      "Name": "_Background Preview",
      "EyeX": -45.31781768798828,
      "EyeY": 36.26472473144531,
      "EyeZ": 42.47948455810547,
      "LookX": 22.516674041748047,
      "LookY": -30.556827545166016,
      "LookZ": -83.90057373046875,
      "UpX": 0.03158741071820259,
      "UpY": 0.9925462007522583,
      "UpZ": -0.1177048310637474
    },
    "ConnectorPins": [],
    "NodeViews": [
      {
        "Id": "dcd67bb8cb174bfd8eb46b274ec43096",
        "Name": "File Path",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 25.333333333333258,
        "Y": 90.66666666666663
      },
      {
        "Id": "383cf8973b224494bc49069d2203d5fd",
        "Name": "Python Script",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": false,
        "X": 688.0,
        "Y": 93.3333333333334
      },
      {
        "Id": "0ca28f3674604398a3938bc7bbdc69b3",
        "Name": "Python Script",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": false,
        "X": 687.9431632192466,
        "Y": 274.13997573249594
      },
      {
        "Id": "eaa281ca188b44dca87a407fb889d3a6",
        "Name": "File Path",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": -34.263441973610384,
        "Y": 274.24084898421097
      },
      {
        "Id": "615b0f583f174f1882622e2d62574d16",
        "Name": "GeomPreview",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 1030.6917828935395,
        "Y": 309.5156126367016
      },
      {
        "Id": "d63d1b17a5be409e8da20c72b3e4bd05",
        "Name": "GeomPreview",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "ShowGeometry": true,
        "X": 1015.9595144808968,
        "Y": 97.4377867333832
      }
    ],
    "Annotations": [],
    "X": 39.506342681087744,
    "Y": -37.501472204816594,
    "Zoom": 0.4405253918378805
  }
}